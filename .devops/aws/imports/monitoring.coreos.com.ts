// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * The `PodMonitor` custom resource definition (CRD) defines how `Prometheus` and `PrometheusAgent` can scrape metrics from a group of pods.
Among other things, it allows to specify:
* The pods to scrape via label selectors.
* The container ports to scrape.
* Authentication credentials to use.
* Target and metric relabeling.

`Prometheus` and `PrometheusAgent` objects select `PodMonitor` objects using label and namespace selectors.
 *
 * @schema PodMonitor
 */
export class PodMonitor extends ApiObject {
  /**
   * Returns the apiVersion and kind for "PodMonitor"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'monitoring.coreos.com/v1',
    kind: 'PodMonitor',
  }

  /**
   * Renders a Kubernetes manifest for "PodMonitor".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PodMonitorProps): any {
    return {
      ...PodMonitor.GVK,
      ...toJson_PodMonitorProps(props),
    };
  }

  /**
   * Defines a "PodMonitor" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PodMonitorProps) {
    super(scope, id, {
      ...PodMonitor.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...PodMonitor.GVK,
      ...toJson_PodMonitorProps(resolved),
    };
  }
}

/**
 * The `PodMonitor` custom resource definition (CRD) defines how `Prometheus` and `PrometheusAgent` can scrape metrics from a group of pods.
 * Among other things, it allows to specify:
 * * The pods to scrape via label selectors.
 * * The container ports to scrape.
 * * Authentication credentials to use.
 * * Target and metric relabeling.
 *
 * `Prometheus` and `PrometheusAgent` objects select `PodMonitor` objects using label and namespace selectors.
 *
 * @schema PodMonitor
 */
export interface PodMonitorProps {
  /**
   * @schema PodMonitor#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Specification of desired Pod selection for target discovery by Prometheus.
   *
   * @schema PodMonitor#spec
   */
  readonly spec: PodMonitorSpec;

}

/**
 * Converts an object of type 'PodMonitorProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodMonitorProps(obj: PodMonitorProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PodMonitorSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specification of desired Pod selection for target discovery by Prometheus.
 *
 * @schema PodMonitorSpec
 */
export interface PodMonitorSpec {
  /**
   * `attachMetadata` defines additional metadata which is added to the
   * discovered targets.
   *
   * It requires Prometheus >= v2.35.0.
   *
   * @schema PodMonitorSpec#attachMetadata
   */
  readonly attachMetadata?: PodMonitorSpecAttachMetadata;

  /**
   * When defined, bodySizeLimit specifies a job level limit on the size
   * of uncompressed response body that will be accepted by Prometheus.
   *
   * It requires Prometheus >= v2.28.0.
   *
   * @schema PodMonitorSpec#bodySizeLimit
   */
  readonly bodySizeLimit?: string;

  /**
   * The label to use to retrieve the job name from.
   * `jobLabel` selects the label from the associated Kubernetes `Pod`
   * object which will be used as the `job` label for all metrics.
   *
   * For example if `jobLabel` is set to `foo` and the Kubernetes `Pod`
   * object is labeled with `foo: bar`, then Prometheus adds the `job="bar"`
   * label to all ingested metrics.
   *
   * If the value of this field is empty, the `job` label of the metrics
   * defaults to the namespace and name of the PodMonitor object (e.g. `<namespace>/<name>`).
   *
   * @schema PodMonitorSpec#jobLabel
   */
  readonly jobLabel?: string;

  /**
   * Per-scrape limit on the number of targets dropped by relabeling
   * that will be kept in memory. 0 means no limit.
   *
   * It requires Prometheus >= v2.47.0.
   *
   * @schema PodMonitorSpec#keepDroppedTargets
   */
  readonly keepDroppedTargets?: number;

  /**
   * Per-scrape limit on number of labels that will be accepted for a sample.
   *
   * It requires Prometheus >= v2.27.0.
   *
   * @schema PodMonitorSpec#labelLimit
   */
  readonly labelLimit?: number;

  /**
   * Per-scrape limit on length of labels name that will be accepted for a sample.
   *
   * It requires Prometheus >= v2.27.0.
   *
   * @schema PodMonitorSpec#labelNameLengthLimit
   */
  readonly labelNameLengthLimit?: number;

  /**
   * Per-scrape limit on length of labels value that will be accepted for a sample.
   *
   * It requires Prometheus >= v2.27.0.
   *
   * @schema PodMonitorSpec#labelValueLengthLimit
   */
  readonly labelValueLengthLimit?: number;

  /**
   * `namespaceSelector` defines in which namespace(s) Prometheus should discover the pods.
   * By default, the pods are discovered in the same namespace as the `PodMonitor` object but it is possible to select pods across different/all namespaces.
   *
   * @schema PodMonitorSpec#namespaceSelector
   */
  readonly namespaceSelector?: PodMonitorSpecNamespaceSelector;

  /**
   * If there are more than this many buckets in a native histogram,
   * buckets will be merged to stay within the limit.
   * It requires Prometheus >= v2.45.0.
   *
   * @schema PodMonitorSpec#nativeHistogramBucketLimit
   */
  readonly nativeHistogramBucketLimit?: number;

  /**
   * If the growth factor of one bucket to the next is smaller than this,
   * buckets will be merged to increase the factor sufficiently.
   * It requires Prometheus >= v2.50.0.
   *
   * @schema PodMonitorSpec#nativeHistogramMinBucketFactor
   */
  readonly nativeHistogramMinBucketFactor?: PodMonitorSpecNativeHistogramMinBucketFactor;

  /**
   * Defines how to scrape metrics from the selected pods.
   *
   * @schema PodMonitorSpec#podMetricsEndpoints
   */
  readonly podMetricsEndpoints?: PodMonitorSpecPodMetricsEndpoints[];

  /**
   * `podTargetLabels` defines the labels which are transferred from the
   * associated Kubernetes `Pod` object onto the ingested metrics.
   *
   * @schema PodMonitorSpec#podTargetLabels
   */
  readonly podTargetLabels?: string[];

  /**
   * `sampleLimit` defines a per-scrape limit on the number of scraped samples
   * that will be accepted.
   *
   * @schema PodMonitorSpec#sampleLimit
   */
  readonly sampleLimit?: number;

  /**
   * The scrape class to apply.
   *
   * @schema PodMonitorSpec#scrapeClass
   */
  readonly scrapeClass?: string;

  /**
   * Whether to scrape a classic histogram that is also exposed as a native histogram.
   * It requires Prometheus >= v2.45.0.
   *
   * @schema PodMonitorSpec#scrapeClassicHistograms
   */
  readonly scrapeClassicHistograms?: boolean;

  /**
   * `scrapeProtocols` defines the protocols to negotiate during a scrape. It tells clients the
   * protocols supported by Prometheus in order of preference (from most to least preferred).
   *
   * If unset, Prometheus uses its default value.
   *
   * It requires Prometheus >= v2.49.0.
   *
   * @schema PodMonitorSpec#scrapeProtocols
   */
  readonly scrapeProtocols?: PodMonitorSpecScrapeProtocols[];

  /**
   * Label selector to select the Kubernetes `Pod` objects to scrape metrics from.
   *
   * @schema PodMonitorSpec#selector
   */
  readonly selector: PodMonitorSpecSelector;

  /**
   * `targetLimit` defines a limit on the number of scraped targets that will
   * be accepted.
   *
   * @schema PodMonitorSpec#targetLimit
   */
  readonly targetLimit?: number;

}

/**
 * Converts an object of type 'PodMonitorSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodMonitorSpec(obj: PodMonitorSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attachMetadata': toJson_PodMonitorSpecAttachMetadata(obj.attachMetadata),
    'bodySizeLimit': obj.bodySizeLimit,
    'jobLabel': obj.jobLabel,
    'keepDroppedTargets': obj.keepDroppedTargets,
    'labelLimit': obj.labelLimit,
    'labelNameLengthLimit': obj.labelNameLengthLimit,
    'labelValueLengthLimit': obj.labelValueLengthLimit,
    'namespaceSelector': toJson_PodMonitorSpecNamespaceSelector(obj.namespaceSelector),
    'nativeHistogramBucketLimit': obj.nativeHistogramBucketLimit,
    'nativeHistogramMinBucketFactor': obj.nativeHistogramMinBucketFactor?.value,
    'podMetricsEndpoints': obj.podMetricsEndpoints?.map(y => toJson_PodMonitorSpecPodMetricsEndpoints(y)),
    'podTargetLabels': obj.podTargetLabels?.map(y => y),
    'sampleLimit': obj.sampleLimit,
    'scrapeClass': obj.scrapeClass,
    'scrapeClassicHistograms': obj.scrapeClassicHistograms,
    'scrapeProtocols': obj.scrapeProtocols?.map(y => y),
    'selector': toJson_PodMonitorSpecSelector(obj.selector),
    'targetLimit': obj.targetLimit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `attachMetadata` defines additional metadata which is added to the
 * discovered targets.
 *
 * It requires Prometheus >= v2.35.0.
 *
 * @schema PodMonitorSpecAttachMetadata
 */
export interface PodMonitorSpecAttachMetadata {
  /**
   * When set to true, Prometheus attaches node metadata to the discovered
   * targets.
   *
   * The Prometheus service account must have the `list` and `watch`
   * permissions on the `Nodes` objects.
   *
   * @schema PodMonitorSpecAttachMetadata#node
   */
  readonly node?: boolean;

}

/**
 * Converts an object of type 'PodMonitorSpecAttachMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodMonitorSpecAttachMetadata(obj: PodMonitorSpecAttachMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'node': obj.node,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `namespaceSelector` defines in which namespace(s) Prometheus should discover the pods.
 * By default, the pods are discovered in the same namespace as the `PodMonitor` object but it is possible to select pods across different/all namespaces.
 *
 * @schema PodMonitorSpecNamespaceSelector
 */
export interface PodMonitorSpecNamespaceSelector {
  /**
   * Boolean describing whether all namespaces are selected in contrast to a
   * list restricting them.
   *
   * @schema PodMonitorSpecNamespaceSelector#any
   */
  readonly any?: boolean;

  /**
   * List of namespace names to select from.
   *
   * @schema PodMonitorSpecNamespaceSelector#matchNames
   */
  readonly matchNames?: string[];

}

/**
 * Converts an object of type 'PodMonitorSpecNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodMonitorSpecNamespaceSelector(obj: PodMonitorSpecNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'any': obj.any,
    'matchNames': obj.matchNames?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * If the growth factor of one bucket to the next is smaller than this,
 * buckets will be merged to increase the factor sufficiently.
 * It requires Prometheus >= v2.50.0.
 *
 * @schema PodMonitorSpecNativeHistogramMinBucketFactor
 */
export class PodMonitorSpecNativeHistogramMinBucketFactor {
  public static fromNumber(value: number): PodMonitorSpecNativeHistogramMinBucketFactor {
    return new PodMonitorSpecNativeHistogramMinBucketFactor(value);
  }
  public static fromString(value: string): PodMonitorSpecNativeHistogramMinBucketFactor {
    return new PodMonitorSpecNativeHistogramMinBucketFactor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * PodMetricsEndpoint defines an endpoint serving Prometheus metrics to be scraped by
 * Prometheus.
 *
 * @schema PodMonitorSpecPodMetricsEndpoints
 */
export interface PodMonitorSpecPodMetricsEndpoints {
  /**
   * `authorization` configures the Authorization header credentials to use when
   * scraping the target.
   *
   * Cannot be set at the same time as `basicAuth`, or `oauth2`.
   *
   * @schema PodMonitorSpecPodMetricsEndpoints#authorization
   */
  readonly authorization?: PodMonitorSpecPodMetricsEndpointsAuthorization;

  /**
   * `basicAuth` configures the Basic Authentication credentials to use when
   * scraping the target.
   *
   * Cannot be set at the same time as `authorization`, or `oauth2`.
   *
   * @schema PodMonitorSpecPodMetricsEndpoints#basicAuth
   */
  readonly basicAuth?: PodMonitorSpecPodMetricsEndpointsBasicAuth;

  /**
   * `bearerTokenSecret` specifies a key of a Secret containing the bearer
   * token for scraping targets. The secret needs to be in the same namespace
   * as the PodMonitor object and readable by the Prometheus Operator.
   *
   * Deprecated: use `authorization` instead.
   *
   * @schema PodMonitorSpecPodMetricsEndpoints#bearerTokenSecret
   */
  readonly bearerTokenSecret?: PodMonitorSpecPodMetricsEndpointsBearerTokenSecret;

  /**
   * `enableHttp2` can be used to disable HTTP2 when scraping the target.
   *
   * @schema PodMonitorSpecPodMetricsEndpoints#enableHttp2
   */
  readonly enableHttp2?: boolean;

  /**
   * When true, the pods which are not running (e.g. either in Failed or
   * Succeeded state) are dropped during the target discovery.
   *
   * If unset, the filtering is enabled.
   *
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase
   *
   * @schema PodMonitorSpecPodMetricsEndpoints#filterRunning
   */
  readonly filterRunning?: boolean;

  /**
   * `followRedirects` defines whether the scrape requests should follow HTTP
   * 3xx redirects.
   *
   * @schema PodMonitorSpecPodMetricsEndpoints#followRedirects
   */
  readonly followRedirects?: boolean;

  /**
   * When true, `honorLabels` preserves the metric's labels when they collide
   * with the target's labels.
   *
   * @schema PodMonitorSpecPodMetricsEndpoints#honorLabels
   */
  readonly honorLabels?: boolean;

  /**
   * `honorTimestamps` controls whether Prometheus preserves the timestamps
   * when exposed by the target.
   *
   * @schema PodMonitorSpecPodMetricsEndpoints#honorTimestamps
   */
  readonly honorTimestamps?: boolean;

  /**
   * Interval at which Prometheus scrapes the metrics from the target.
   *
   * If empty, Prometheus uses the global scrape interval.
   *
   * @schema PodMonitorSpecPodMetricsEndpoints#interval
   */
  readonly interval?: string;

  /**
   * `metricRelabelings` configures the relabeling rules to apply to the
   * samples before ingestion.
   *
   * @schema PodMonitorSpecPodMetricsEndpoints#metricRelabelings
   */
  readonly metricRelabelings?: PodMonitorSpecPodMetricsEndpointsMetricRelabelings[];

  /**
   * `oauth2` configures the OAuth2 settings to use when scraping the target.
   *
   * It requires Prometheus >= 2.27.0.
   *
   * Cannot be set at the same time as `authorization`, or `basicAuth`.
   *
   * @schema PodMonitorSpecPodMetricsEndpoints#oauth2
   */
  readonly oauth2?: PodMonitorSpecPodMetricsEndpointsOauth2;

  /**
   * `params` define optional HTTP URL parameters.
   *
   * @schema PodMonitorSpecPodMetricsEndpoints#params
   */
  readonly params?: { [key: string]: string[] };

  /**
   * HTTP path from which to scrape for metrics.
   *
   * If empty, Prometheus uses the default value (e.g. `/metrics`).
   *
   * @schema PodMonitorSpecPodMetricsEndpoints#path
   */
  readonly path?: string;

  /**
   * Name of the Pod port which this endpoint refers to.
   *
   * It takes precedence over `targetPort`.
   *
   * @schema PodMonitorSpecPodMetricsEndpoints#port
   */
  readonly port?: string;

  /**
   * `proxyURL` configures the HTTP Proxy URL (e.g.
   * "http://proxyserver:2195") to go through when scraping the target.
   *
   * @schema PodMonitorSpecPodMetricsEndpoints#proxyUrl
   */
  readonly proxyUrl?: string;

  /**
   * `relabelings` configures the relabeling rules to apply the target's
   * metadata labels.
   *
   * The Operator automatically adds relabelings for a few standard Kubernetes fields.
   *
   * The original scrape job's name is available via the `__tmp_prometheus_job_name` label.
   *
   * More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
   *
   * @schema PodMonitorSpecPodMetricsEndpoints#relabelings
   */
  readonly relabelings?: PodMonitorSpecPodMetricsEndpointsRelabelings[];

  /**
   * HTTP scheme to use for scraping.
   *
   * `http` and `https` are the expected values unless you rewrite the
   * `__scheme__` label via relabeling.
   *
   * If empty, Prometheus uses the default value `http`.
   *
   * @schema PodMonitorSpecPodMetricsEndpoints#scheme
   */
  readonly scheme?: PodMonitorSpecPodMetricsEndpointsScheme;

  /**
   * Timeout after which Prometheus considers the scrape to be failed.
   *
   * If empty, Prometheus uses the global scrape timeout unless it is less
   * than the target's scrape interval value in which the latter is used.
   *
   * @schema PodMonitorSpecPodMetricsEndpoints#scrapeTimeout
   */
  readonly scrapeTimeout?: string;

  /**
   * Name or number of the target port of the `Pod` object behind the Service, the
   * port must be specified with container port property.
   *
   * Deprecated: use 'port' instead.
   *
   * @schema PodMonitorSpecPodMetricsEndpoints#targetPort
   */
  readonly targetPort?: PodMonitorSpecPodMetricsEndpointsTargetPort;

  /**
   * TLS configuration to use when scraping the target.
   *
   * @schema PodMonitorSpecPodMetricsEndpoints#tlsConfig
   */
  readonly tlsConfig?: PodMonitorSpecPodMetricsEndpointsTlsConfig;

  /**
   * `trackTimestampsStaleness` defines whether Prometheus tracks staleness of
   * the metrics that have an explicit timestamp present in scraped data.
   * Has no effect if `honorTimestamps` is false.
   *
   * It requires Prometheus >= v2.48.0.
   *
   * @schema PodMonitorSpecPodMetricsEndpoints#trackTimestampsStaleness
   */
  readonly trackTimestampsStaleness?: boolean;

}

/**
 * Converts an object of type 'PodMonitorSpecPodMetricsEndpoints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodMonitorSpecPodMetricsEndpoints(obj: PodMonitorSpecPodMetricsEndpoints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorization': toJson_PodMonitorSpecPodMetricsEndpointsAuthorization(obj.authorization),
    'basicAuth': toJson_PodMonitorSpecPodMetricsEndpointsBasicAuth(obj.basicAuth),
    'bearerTokenSecret': toJson_PodMonitorSpecPodMetricsEndpointsBearerTokenSecret(obj.bearerTokenSecret),
    'enableHttp2': obj.enableHttp2,
    'filterRunning': obj.filterRunning,
    'followRedirects': obj.followRedirects,
    'honorLabels': obj.honorLabels,
    'honorTimestamps': obj.honorTimestamps,
    'interval': obj.interval,
    'metricRelabelings': obj.metricRelabelings?.map(y => toJson_PodMonitorSpecPodMetricsEndpointsMetricRelabelings(y)),
    'oauth2': toJson_PodMonitorSpecPodMetricsEndpointsOauth2(obj.oauth2),
    'params': ((obj.params) === undefined) ? undefined : (Object.entries(obj.params).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.map(y => y) }), {})),
    'path': obj.path,
    'port': obj.port,
    'proxyUrl': obj.proxyUrl,
    'relabelings': obj.relabelings?.map(y => toJson_PodMonitorSpecPodMetricsEndpointsRelabelings(y)),
    'scheme': obj.scheme,
    'scrapeTimeout': obj.scrapeTimeout,
    'targetPort': obj.targetPort?.value,
    'tlsConfig': toJson_PodMonitorSpecPodMetricsEndpointsTlsConfig(obj.tlsConfig),
    'trackTimestampsStaleness': obj.trackTimestampsStaleness,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ScrapeProtocol represents a protocol used by Prometheus for scraping metrics.
 * Supported values are:
 * * `OpenMetricsText0.0.1`
 * * `OpenMetricsText1.0.0`
 * * `PrometheusProto`
 * * `PrometheusText0.0.4`
 *
 * @schema PodMonitorSpecScrapeProtocols
 */
export enum PodMonitorSpecScrapeProtocols {
  /** PrometheusProto */
  PROMETHEUS_PROTO = "PrometheusProto",
  /** OpenMetricsText0.0.1 */
  OPEN_METRICS_TEXT0_0_1 = "OpenMetricsText0.0.1",
  /** OpenMetricsText1.0.0 */
  OPEN_METRICS_TEXT1_0_0 = "OpenMetricsText1.0.0",
  /** PrometheusText0.0.4 */
  PROMETHEUS_TEXT0_0_4 = "PrometheusText0.0.4",
}

/**
 * Label selector to select the Kubernetes `Pod` objects to scrape metrics from.
 *
 * @schema PodMonitorSpecSelector
 */
export interface PodMonitorSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PodMonitorSpecSelector#matchExpressions
   */
  readonly matchExpressions?: PodMonitorSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PodMonitorSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'PodMonitorSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodMonitorSpecSelector(obj: PodMonitorSpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_PodMonitorSpecSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `authorization` configures the Authorization header credentials to use when
 * scraping the target.
 *
 * Cannot be set at the same time as `basicAuth`, or `oauth2`.
 *
 * @schema PodMonitorSpecPodMetricsEndpointsAuthorization
 */
export interface PodMonitorSpecPodMetricsEndpointsAuthorization {
  /**
   * Selects a key of a Secret in the namespace that contains the credentials for authentication.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsAuthorization#credentials
   */
  readonly credentials?: PodMonitorSpecPodMetricsEndpointsAuthorizationCredentials;

  /**
   * Defines the authentication type. The value is case-insensitive.
   *
   * "Basic" is not a supported value.
   *
   * Default: "Bearer"
   *
   * @schema PodMonitorSpecPodMetricsEndpointsAuthorization#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'PodMonitorSpecPodMetricsEndpointsAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodMonitorSpecPodMetricsEndpointsAuthorization(obj: PodMonitorSpecPodMetricsEndpointsAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_PodMonitorSpecPodMetricsEndpointsAuthorizationCredentials(obj.credentials),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `basicAuth` configures the Basic Authentication credentials to use when
 * scraping the target.
 *
 * Cannot be set at the same time as `authorization`, or `oauth2`.
 *
 * @schema PodMonitorSpecPodMetricsEndpointsBasicAuth
 */
export interface PodMonitorSpecPodMetricsEndpointsBasicAuth {
  /**
   * `password` specifies a key of a Secret containing the password for
   * authentication.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsBasicAuth#password
   */
  readonly password?: PodMonitorSpecPodMetricsEndpointsBasicAuthPassword;

  /**
   * `username` specifies a key of a Secret containing the username for
   * authentication.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsBasicAuth#username
   */
  readonly username?: PodMonitorSpecPodMetricsEndpointsBasicAuthUsername;

}

/**
 * Converts an object of type 'PodMonitorSpecPodMetricsEndpointsBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodMonitorSpecPodMetricsEndpointsBasicAuth(obj: PodMonitorSpecPodMetricsEndpointsBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_PodMonitorSpecPodMetricsEndpointsBasicAuthPassword(obj.password),
    'username': toJson_PodMonitorSpecPodMetricsEndpointsBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `bearerTokenSecret` specifies a key of a Secret containing the bearer
 * token for scraping targets. The secret needs to be in the same namespace
 * as the PodMonitor object and readable by the Prometheus Operator.
 *
 * Deprecated: use `authorization` instead.
 *
 * @schema PodMonitorSpecPodMetricsEndpointsBearerTokenSecret
 */
export interface PodMonitorSpecPodMetricsEndpointsBearerTokenSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsBearerTokenSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema PodMonitorSpecPodMetricsEndpointsBearerTokenSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PodMonitorSpecPodMetricsEndpointsBearerTokenSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PodMonitorSpecPodMetricsEndpointsBearerTokenSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodMonitorSpecPodMetricsEndpointsBearerTokenSecret(obj: PodMonitorSpecPodMetricsEndpointsBearerTokenSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RelabelConfig allows dynamic rewriting of the label set for targets, alerts,
 * scraped samples and remote write samples.
 *
 * More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
 *
 * @schema PodMonitorSpecPodMetricsEndpointsMetricRelabelings
 */
export interface PodMonitorSpecPodMetricsEndpointsMetricRelabelings {
  /**
   * Action to perform based on the regex matching.
   *
   * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.
   * `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
   *
   * Default: "Replace"
   *
   * @schema PodMonitorSpecPodMetricsEndpointsMetricRelabelings#action
   */
  readonly action?: PodMonitorSpecPodMetricsEndpointsMetricRelabelingsAction;

  /**
   * Modulus to take of the hash of the source label values.
   *
   * Only applicable when the action is `HashMod`.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsMetricRelabelings#modulus
   */
  readonly modulus?: number;

  /**
   * Regular expression against which the extracted value is matched.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsMetricRelabelings#regex
   */
  readonly regex?: string;

  /**
   * Replacement value against which a Replace action is performed if the
   * regular expression matches.
   *
   * Regex capture groups are available.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsMetricRelabelings#replacement
   */
  readonly replacement?: string;

  /**
   * Separator is the string between concatenated SourceLabels.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsMetricRelabelings#separator
   */
  readonly separator?: string;

  /**
   * The source labels select values from existing labels. Their content is
   * concatenated using the configured Separator and matched against the
   * configured regular expression.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsMetricRelabelings#sourceLabels
   */
  readonly sourceLabels?: string[];

  /**
   * Label to which the resulting string is written in a replacement.
   *
   * It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`,
   * `KeepEqual` and `DropEqual` actions.
   *
   * Regex capture groups are available.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsMetricRelabelings#targetLabel
   */
  readonly targetLabel?: string;

}

/**
 * Converts an object of type 'PodMonitorSpecPodMetricsEndpointsMetricRelabelings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodMonitorSpecPodMetricsEndpointsMetricRelabelings(obj: PodMonitorSpecPodMetricsEndpointsMetricRelabelings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'modulus': obj.modulus,
    'regex': obj.regex,
    'replacement': obj.replacement,
    'separator': obj.separator,
    'sourceLabels': obj.sourceLabels?.map(y => y),
    'targetLabel': obj.targetLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `oauth2` configures the OAuth2 settings to use when scraping the target.
 *
 * It requires Prometheus >= 2.27.0.
 *
 * Cannot be set at the same time as `authorization`, or `basicAuth`.
 *
 * @schema PodMonitorSpecPodMetricsEndpointsOauth2
 */
export interface PodMonitorSpecPodMetricsEndpointsOauth2 {
  /**
   * `clientId` specifies a key of a Secret or ConfigMap containing the
   * OAuth2 client's ID.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2#clientId
   */
  readonly clientId: PodMonitorSpecPodMetricsEndpointsOauth2ClientId;

  /**
   * `clientSecret` specifies a key of a Secret containing the OAuth2
   * client's secret.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2#clientSecret
   */
  readonly clientSecret: PodMonitorSpecPodMetricsEndpointsOauth2ClientSecret;

  /**
   * `endpointParams` configures the HTTP parameters to append to the token
   * URL.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2#endpointParams
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names
   * that should be excluded from proxying. IP and domain names can
   * contain port numbers.
   *
   * It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2#noProxy
   */
  readonly noProxy?: string;

  /**
   * ProxyConnectHeader optionally specifies headers to send to
   * proxies during CONNECT requests.
   *
   * It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2#proxyConnectHeader
   */
  readonly proxyConnectHeader?: { [key: string]: PodMonitorSpecPodMetricsEndpointsOauth2ProxyConnectHeader[] };

  /**
   * Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
   *
   * It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2#proxyFromEnvironment
   */
  readonly proxyFromEnvironment?: boolean;

  /**
   * `proxyURL` defines the HTTP proxy server to use.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2#proxyUrl
   */
  readonly proxyUrl?: string;

  /**
   * `scopes` defines the OAuth2 scopes used for the token request.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * TLS configuration to use when connecting to the OAuth2 server.
   * It requires Prometheus >= v2.43.0.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2#tlsConfig
   */
  readonly tlsConfig?: PodMonitorSpecPodMetricsEndpointsOauth2TlsConfig;

  /**
   * `tokenURL` configures the URL to fetch the token from.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2#tokenUrl
   */
  readonly tokenUrl: string;

}

/**
 * Converts an object of type 'PodMonitorSpecPodMetricsEndpointsOauth2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodMonitorSpecPodMetricsEndpointsOauth2(obj: PodMonitorSpecPodMetricsEndpointsOauth2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientId': toJson_PodMonitorSpecPodMetricsEndpointsOauth2ClientId(obj.clientId),
    'clientSecret': toJson_PodMonitorSpecPodMetricsEndpointsOauth2ClientSecret(obj.clientSecret),
    'endpointParams': ((obj.endpointParams) === undefined) ? undefined : (Object.entries(obj.endpointParams).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'noProxy': obj.noProxy,
    'proxyConnectHeader': ((obj.proxyConnectHeader) === undefined) ? undefined : (Object.entries(obj.proxyConnectHeader).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.map(y => toJson_PodMonitorSpecPodMetricsEndpointsOauth2ProxyConnectHeader(y)) }), {})),
    'proxyFromEnvironment': obj.proxyFromEnvironment,
    'proxyUrl': obj.proxyUrl,
    'scopes': obj.scopes?.map(y => y),
    'tlsConfig': toJson_PodMonitorSpecPodMetricsEndpointsOauth2TlsConfig(obj.tlsConfig),
    'tokenUrl': obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RelabelConfig allows dynamic rewriting of the label set for targets, alerts,
 * scraped samples and remote write samples.
 *
 * More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
 *
 * @schema PodMonitorSpecPodMetricsEndpointsRelabelings
 */
export interface PodMonitorSpecPodMetricsEndpointsRelabelings {
  /**
   * Action to perform based on the regex matching.
   *
   * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.
   * `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
   *
   * Default: "Replace"
   *
   * @schema PodMonitorSpecPodMetricsEndpointsRelabelings#action
   */
  readonly action?: PodMonitorSpecPodMetricsEndpointsRelabelingsAction;

  /**
   * Modulus to take of the hash of the source label values.
   *
   * Only applicable when the action is `HashMod`.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsRelabelings#modulus
   */
  readonly modulus?: number;

  /**
   * Regular expression against which the extracted value is matched.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsRelabelings#regex
   */
  readonly regex?: string;

  /**
   * Replacement value against which a Replace action is performed if the
   * regular expression matches.
   *
   * Regex capture groups are available.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsRelabelings#replacement
   */
  readonly replacement?: string;

  /**
   * Separator is the string between concatenated SourceLabels.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsRelabelings#separator
   */
  readonly separator?: string;

  /**
   * The source labels select values from existing labels. Their content is
   * concatenated using the configured Separator and matched against the
   * configured regular expression.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsRelabelings#sourceLabels
   */
  readonly sourceLabels?: string[];

  /**
   * Label to which the resulting string is written in a replacement.
   *
   * It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`,
   * `KeepEqual` and `DropEqual` actions.
   *
   * Regex capture groups are available.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsRelabelings#targetLabel
   */
  readonly targetLabel?: string;

}

/**
 * Converts an object of type 'PodMonitorSpecPodMetricsEndpointsRelabelings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodMonitorSpecPodMetricsEndpointsRelabelings(obj: PodMonitorSpecPodMetricsEndpointsRelabelings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'modulus': obj.modulus,
    'regex': obj.regex,
    'replacement': obj.replacement,
    'separator': obj.separator,
    'sourceLabels': obj.sourceLabels?.map(y => y),
    'targetLabel': obj.targetLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTP scheme to use for scraping.
 *
 * `http` and `https` are the expected values unless you rewrite the
 * `__scheme__` label via relabeling.
 *
 * If empty, Prometheus uses the default value `http`.
 *
 * @schema PodMonitorSpecPodMetricsEndpointsScheme
 */
export enum PodMonitorSpecPodMetricsEndpointsScheme {
  /** http */
  HTTP = "http",
  /** https */
  HTTPS = "https",
}

/**
 * Name or number of the target port of the `Pod` object behind the Service, the
 * port must be specified with container port property.
 *
 * Deprecated: use 'port' instead.
 *
 * @schema PodMonitorSpecPodMetricsEndpointsTargetPort
 */
export class PodMonitorSpecPodMetricsEndpointsTargetPort {
  public static fromNumber(value: number): PodMonitorSpecPodMetricsEndpointsTargetPort {
    return new PodMonitorSpecPodMetricsEndpointsTargetPort(value);
  }
  public static fromString(value: string): PodMonitorSpecPodMetricsEndpointsTargetPort {
    return new PodMonitorSpecPodMetricsEndpointsTargetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * TLS configuration to use when scraping the target.
 *
 * @schema PodMonitorSpecPodMetricsEndpointsTlsConfig
 */
export interface PodMonitorSpecPodMetricsEndpointsTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsTlsConfig#ca
   */
  readonly ca?: PodMonitorSpecPodMetricsEndpointsTlsConfigCa;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsTlsConfig#cert
   */
  readonly cert?: PodMonitorSpecPodMetricsEndpointsTlsConfigCert;

  /**
   * Disable target certificate validation.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsTlsConfig#keySecret
   */
  readonly keySecret?: PodMonitorSpecPodMetricsEndpointsTlsConfigKeySecret;

  /**
   * Maximum acceptable TLS version.
   *
   * It requires Prometheus >= v2.41.0.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsTlsConfig#maxVersion
   */
  readonly maxVersion?: PodMonitorSpecPodMetricsEndpointsTlsConfigMaxVersion;

  /**
   * Minimum acceptable TLS version.
   *
   * It requires Prometheus >= v2.35.0.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsTlsConfig#minVersion
   */
  readonly minVersion?: PodMonitorSpecPodMetricsEndpointsTlsConfigMinVersion;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'PodMonitorSpecPodMetricsEndpointsTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodMonitorSpecPodMetricsEndpointsTlsConfig(obj: PodMonitorSpecPodMetricsEndpointsTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_PodMonitorSpecPodMetricsEndpointsTlsConfigCa(obj.ca),
    'cert': toJson_PodMonitorSpecPodMetricsEndpointsTlsConfigCert(obj.cert),
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keySecret': toJson_PodMonitorSpecPodMetricsEndpointsTlsConfigKeySecret(obj.keySecret),
    'maxVersion': obj.maxVersion,
    'minVersion': obj.minVersion,
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema PodMonitorSpecSelectorMatchExpressions
 */
export interface PodMonitorSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PodMonitorSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PodMonitorSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema PodMonitorSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'PodMonitorSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodMonitorSpecSelectorMatchExpressions(obj: PodMonitorSpecSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a Secret in the namespace that contains the credentials for authentication.
 *
 * @schema PodMonitorSpecPodMetricsEndpointsAuthorizationCredentials
 */
export interface PodMonitorSpecPodMetricsEndpointsAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema PodMonitorSpecPodMetricsEndpointsAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PodMonitorSpecPodMetricsEndpointsAuthorizationCredentials#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PodMonitorSpecPodMetricsEndpointsAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodMonitorSpecPodMetricsEndpointsAuthorizationCredentials(obj: PodMonitorSpecPodMetricsEndpointsAuthorizationCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `password` specifies a key of a Secret containing the password for
 * authentication.
 *
 * @schema PodMonitorSpecPodMetricsEndpointsBasicAuthPassword
 */
export interface PodMonitorSpecPodMetricsEndpointsBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema PodMonitorSpecPodMetricsEndpointsBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PodMonitorSpecPodMetricsEndpointsBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PodMonitorSpecPodMetricsEndpointsBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodMonitorSpecPodMetricsEndpointsBasicAuthPassword(obj: PodMonitorSpecPodMetricsEndpointsBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `username` specifies a key of a Secret containing the username for
 * authentication.
 *
 * @schema PodMonitorSpecPodMetricsEndpointsBasicAuthUsername
 */
export interface PodMonitorSpecPodMetricsEndpointsBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema PodMonitorSpecPodMetricsEndpointsBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PodMonitorSpecPodMetricsEndpointsBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PodMonitorSpecPodMetricsEndpointsBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodMonitorSpecPodMetricsEndpointsBasicAuthUsername(obj: PodMonitorSpecPodMetricsEndpointsBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Action to perform based on the regex matching.
 *
 * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.
 * `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
 *
 * Default: "Replace"
 *
 * @schema PodMonitorSpecPodMetricsEndpointsMetricRelabelingsAction
 */
export enum PodMonitorSpecPodMetricsEndpointsMetricRelabelingsAction {
  /** replace */
  REPLACE = "replace",
  /** keep */
  KEEP = "keep",
  /** drop */
  DROP = "drop",
  /** hashmod */
  HASHMOD = "hashmod",
  /** labelmap */
  LABELMAP = "labelmap",
  /** labeldrop */
  LABELDROP = "labeldrop",
  /** labelkeep */
  LABELKEEP = "labelkeep",
  /** lowercase */
  LOWERCASE = "lowercase",
  /** uppercase */
  UPPERCASE = "uppercase",
  /** keepequal */
  KEEPEQUAL = "keepequal",
  /** dropequal */
  DROPEQUAL = "dropequal",
}

/**
 * `clientId` specifies a key of a Secret or ConfigMap containing the
 * OAuth2 client's ID.
 *
 * @schema PodMonitorSpecPodMetricsEndpointsOauth2ClientId
 */
export interface PodMonitorSpecPodMetricsEndpointsOauth2ClientId {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2ClientId#configMap
   */
  readonly configMap?: PodMonitorSpecPodMetricsEndpointsOauth2ClientIdConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2ClientId#secret
   */
  readonly secret?: PodMonitorSpecPodMetricsEndpointsOauth2ClientIdSecret;

}

/**
 * Converts an object of type 'PodMonitorSpecPodMetricsEndpointsOauth2ClientId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodMonitorSpecPodMetricsEndpointsOauth2ClientId(obj: PodMonitorSpecPodMetricsEndpointsOauth2ClientId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_PodMonitorSpecPodMetricsEndpointsOauth2ClientIdConfigMap(obj.configMap),
    'secret': toJson_PodMonitorSpecPodMetricsEndpointsOauth2ClientIdSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `clientSecret` specifies a key of a Secret containing the OAuth2
 * client's secret.
 *
 * @schema PodMonitorSpecPodMetricsEndpointsOauth2ClientSecret
 */
export interface PodMonitorSpecPodMetricsEndpointsOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2ClientSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PodMonitorSpecPodMetricsEndpointsOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodMonitorSpecPodMetricsEndpointsOauth2ClientSecret(obj: PodMonitorSpecPodMetricsEndpointsOauth2ClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema PodMonitorSpecPodMetricsEndpointsOauth2ProxyConnectHeader
 */
export interface PodMonitorSpecPodMetricsEndpointsOauth2ProxyConnectHeader {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2ProxyConnectHeader#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2ProxyConnectHeader#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2ProxyConnectHeader#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PodMonitorSpecPodMetricsEndpointsOauth2ProxyConnectHeader' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodMonitorSpecPodMetricsEndpointsOauth2ProxyConnectHeader(obj: PodMonitorSpecPodMetricsEndpointsOauth2ProxyConnectHeader | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS configuration to use when connecting to the OAuth2 server.
 * It requires Prometheus >= v2.43.0.
 *
 * @schema PodMonitorSpecPodMetricsEndpointsOauth2TlsConfig
 */
export interface PodMonitorSpecPodMetricsEndpointsOauth2TlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2TlsConfig#ca
   */
  readonly ca?: PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigCa;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2TlsConfig#cert
   */
  readonly cert?: PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigCert;

  /**
   * Disable target certificate validation.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2TlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2TlsConfig#keySecret
   */
  readonly keySecret?: PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigKeySecret;

  /**
   * Maximum acceptable TLS version.
   *
   * It requires Prometheus >= v2.41.0.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2TlsConfig#maxVersion
   */
  readonly maxVersion?: PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigMaxVersion;

  /**
   * Minimum acceptable TLS version.
   *
   * It requires Prometheus >= v2.35.0.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2TlsConfig#minVersion
   */
  readonly minVersion?: PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigMinVersion;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2TlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'PodMonitorSpecPodMetricsEndpointsOauth2TlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodMonitorSpecPodMetricsEndpointsOauth2TlsConfig(obj: PodMonitorSpecPodMetricsEndpointsOauth2TlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigCa(obj.ca),
    'cert': toJson_PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigCert(obj.cert),
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keySecret': toJson_PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigKeySecret(obj.keySecret),
    'maxVersion': obj.maxVersion,
    'minVersion': obj.minVersion,
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Action to perform based on the regex matching.
 *
 * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.
 * `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
 *
 * Default: "Replace"
 *
 * @schema PodMonitorSpecPodMetricsEndpointsRelabelingsAction
 */
export enum PodMonitorSpecPodMetricsEndpointsRelabelingsAction {
  /** replace */
  REPLACE = "replace",
  /** keep */
  KEEP = "keep",
  /** drop */
  DROP = "drop",
  /** hashmod */
  HASHMOD = "hashmod",
  /** labelmap */
  LABELMAP = "labelmap",
  /** labeldrop */
  LABELDROP = "labeldrop",
  /** labelkeep */
  LABELKEEP = "labelkeep",
  /** lowercase */
  LOWERCASE = "lowercase",
  /** uppercase */
  UPPERCASE = "uppercase",
  /** keepequal */
  KEEPEQUAL = "keepequal",
  /** dropequal */
  DROPEQUAL = "dropequal",
}

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema PodMonitorSpecPodMetricsEndpointsTlsConfigCa
 */
export interface PodMonitorSpecPodMetricsEndpointsTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsTlsConfigCa#configMap
   */
  readonly configMap?: PodMonitorSpecPodMetricsEndpointsTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsTlsConfigCa#secret
   */
  readonly secret?: PodMonitorSpecPodMetricsEndpointsTlsConfigCaSecret;

}

/**
 * Converts an object of type 'PodMonitorSpecPodMetricsEndpointsTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodMonitorSpecPodMetricsEndpointsTlsConfigCa(obj: PodMonitorSpecPodMetricsEndpointsTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_PodMonitorSpecPodMetricsEndpointsTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_PodMonitorSpecPodMetricsEndpointsTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema PodMonitorSpecPodMetricsEndpointsTlsConfigCert
 */
export interface PodMonitorSpecPodMetricsEndpointsTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsTlsConfigCert#configMap
   */
  readonly configMap?: PodMonitorSpecPodMetricsEndpointsTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsTlsConfigCert#secret
   */
  readonly secret?: PodMonitorSpecPodMetricsEndpointsTlsConfigCertSecret;

}

/**
 * Converts an object of type 'PodMonitorSpecPodMetricsEndpointsTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodMonitorSpecPodMetricsEndpointsTlsConfigCert(obj: PodMonitorSpecPodMetricsEndpointsTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_PodMonitorSpecPodMetricsEndpointsTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_PodMonitorSpecPodMetricsEndpointsTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema PodMonitorSpecPodMetricsEndpointsTlsConfigKeySecret
 */
export interface PodMonitorSpecPodMetricsEndpointsTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema PodMonitorSpecPodMetricsEndpointsTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PodMonitorSpecPodMetricsEndpointsTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PodMonitorSpecPodMetricsEndpointsTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodMonitorSpecPodMetricsEndpointsTlsConfigKeySecret(obj: PodMonitorSpecPodMetricsEndpointsTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maximum acceptable TLS version.
 *
 * It requires Prometheus >= v2.41.0.
 *
 * @schema PodMonitorSpecPodMetricsEndpointsTlsConfigMaxVersion
 */
export enum PodMonitorSpecPodMetricsEndpointsTlsConfigMaxVersion {
  /** TLS10 */
  TLS10 = "TLS10",
  /** TLS11 */
  TLS11 = "TLS11",
  /** TLS12 */
  TLS12 = "TLS12",
  /** TLS13 */
  TLS13 = "TLS13",
}

/**
 * Minimum acceptable TLS version.
 *
 * It requires Prometheus >= v2.35.0.
 *
 * @schema PodMonitorSpecPodMetricsEndpointsTlsConfigMinVersion
 */
export enum PodMonitorSpecPodMetricsEndpointsTlsConfigMinVersion {
  /** TLS10 */
  TLS10 = "TLS10",
  /** TLS11 */
  TLS11 = "TLS11",
  /** TLS12 */
  TLS12 = "TLS12",
  /** TLS13 */
  TLS13 = "TLS13",
}

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema PodMonitorSpecPodMetricsEndpointsOauth2ClientIdConfigMap
 */
export interface PodMonitorSpecPodMetricsEndpointsOauth2ClientIdConfigMap {
  /**
   * The key to select.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2ClientIdConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2ClientIdConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2ClientIdConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PodMonitorSpecPodMetricsEndpointsOauth2ClientIdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodMonitorSpecPodMetricsEndpointsOauth2ClientIdConfigMap(obj: PodMonitorSpecPodMetricsEndpointsOauth2ClientIdConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema PodMonitorSpecPodMetricsEndpointsOauth2ClientIdSecret
 */
export interface PodMonitorSpecPodMetricsEndpointsOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PodMonitorSpecPodMetricsEndpointsOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodMonitorSpecPodMetricsEndpointsOauth2ClientIdSecret(obj: PodMonitorSpecPodMetricsEndpointsOauth2ClientIdSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigCa
 */
export interface PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigCa#configMap
   */
  readonly configMap?: PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigCa#secret
   */
  readonly secret?: PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigCaSecret;

}

/**
 * Converts an object of type 'PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigCa(obj: PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigCert
 */
export interface PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigCert#configMap
   */
  readonly configMap?: PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigCert#secret
   */
  readonly secret?: PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigCertSecret;

}

/**
 * Converts an object of type 'PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigCert(obj: PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigKeySecret
 */
export interface PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigKeySecret(obj: PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maximum acceptable TLS version.
 *
 * It requires Prometheus >= v2.41.0.
 *
 * @schema PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigMaxVersion
 */
export enum PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigMaxVersion {
  /** TLS10 */
  TLS10 = "TLS10",
  /** TLS11 */
  TLS11 = "TLS11",
  /** TLS12 */
  TLS12 = "TLS12",
  /** TLS13 */
  TLS13 = "TLS13",
}

/**
 * Minimum acceptable TLS version.
 *
 * It requires Prometheus >= v2.35.0.
 *
 * @schema PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigMinVersion
 */
export enum PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigMinVersion {
  /** TLS10 */
  TLS10 = "TLS10",
  /** TLS11 */
  TLS11 = "TLS11",
  /** TLS12 */
  TLS12 = "TLS12",
  /** TLS13 */
  TLS13 = "TLS13",
}

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema PodMonitorSpecPodMetricsEndpointsTlsConfigCaConfigMap
 */
export interface PodMonitorSpecPodMetricsEndpointsTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema PodMonitorSpecPodMetricsEndpointsTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema PodMonitorSpecPodMetricsEndpointsTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PodMonitorSpecPodMetricsEndpointsTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodMonitorSpecPodMetricsEndpointsTlsConfigCaConfigMap(obj: PodMonitorSpecPodMetricsEndpointsTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema PodMonitorSpecPodMetricsEndpointsTlsConfigCaSecret
 */
export interface PodMonitorSpecPodMetricsEndpointsTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema PodMonitorSpecPodMetricsEndpointsTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PodMonitorSpecPodMetricsEndpointsTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PodMonitorSpecPodMetricsEndpointsTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodMonitorSpecPodMetricsEndpointsTlsConfigCaSecret(obj: PodMonitorSpecPodMetricsEndpointsTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema PodMonitorSpecPodMetricsEndpointsTlsConfigCertConfigMap
 */
export interface PodMonitorSpecPodMetricsEndpointsTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema PodMonitorSpecPodMetricsEndpointsTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema PodMonitorSpecPodMetricsEndpointsTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PodMonitorSpecPodMetricsEndpointsTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodMonitorSpecPodMetricsEndpointsTlsConfigCertConfigMap(obj: PodMonitorSpecPodMetricsEndpointsTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema PodMonitorSpecPodMetricsEndpointsTlsConfigCertSecret
 */
export interface PodMonitorSpecPodMetricsEndpointsTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema PodMonitorSpecPodMetricsEndpointsTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PodMonitorSpecPodMetricsEndpointsTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PodMonitorSpecPodMetricsEndpointsTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodMonitorSpecPodMetricsEndpointsTlsConfigCertSecret(obj: PodMonitorSpecPodMetricsEndpointsTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigCaConfigMap
 */
export interface PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigCaConfigMap(obj: PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigCaSecret
 */
export interface PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigCaSecret(obj: PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigCertConfigMap
 */
export interface PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigCertConfigMap(obj: PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigCertSecret
 */
export interface PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigCertSecret(obj: PodMonitorSpecPodMetricsEndpointsOauth2TlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * The `ServiceMonitor` custom resource definition (CRD) defines how `Prometheus` and `PrometheusAgent` can scrape metrics from a group of services.
Among other things, it allows to specify:
* The services to scrape via label selectors.
* The container ports to scrape.
* Authentication credentials to use.
* Target and metric relabeling.

`Prometheus` and `PrometheusAgent` objects select `ServiceMonitor` objects using label and namespace selectors.
 *
 * @schema ServiceMonitor
 */
export class ServiceMonitor extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ServiceMonitor"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'monitoring.coreos.com/v1',
    kind: 'ServiceMonitor',
  }

  /**
   * Renders a Kubernetes manifest for "ServiceMonitor".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ServiceMonitorProps): any {
    return {
      ...ServiceMonitor.GVK,
      ...toJson_ServiceMonitorProps(props),
    };
  }

  /**
   * Defines a "ServiceMonitor" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ServiceMonitorProps) {
    super(scope, id, {
      ...ServiceMonitor.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ServiceMonitor.GVK,
      ...toJson_ServiceMonitorProps(resolved),
    };
  }
}

/**
 * The `ServiceMonitor` custom resource definition (CRD) defines how `Prometheus` and `PrometheusAgent` can scrape metrics from a group of services.
 * Among other things, it allows to specify:
 * * The services to scrape via label selectors.
 * * The container ports to scrape.
 * * Authentication credentials to use.
 * * Target and metric relabeling.
 *
 * `Prometheus` and `PrometheusAgent` objects select `ServiceMonitor` objects using label and namespace selectors.
 *
 * @schema ServiceMonitor
 */
export interface ServiceMonitorProps {
  /**
   * @schema ServiceMonitor#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Specification of desired Service selection for target discovery by
   * Prometheus.
   *
   * @schema ServiceMonitor#spec
   */
  readonly spec: ServiceMonitorSpec;

}

/**
 * Converts an object of type 'ServiceMonitorProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorProps(obj: ServiceMonitorProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ServiceMonitorSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specification of desired Service selection for target discovery by
 * Prometheus.
 *
 * @schema ServiceMonitorSpec
 */
export interface ServiceMonitorSpec {
  /**
   * `attachMetadata` defines additional metadata which is added to the
   * discovered targets.
   *
   * It requires Prometheus >= v2.37.0.
   *
   * @schema ServiceMonitorSpec#attachMetadata
   */
  readonly attachMetadata?: ServiceMonitorSpecAttachMetadata;

  /**
   * When defined, bodySizeLimit specifies a job level limit on the size
   * of uncompressed response body that will be accepted by Prometheus.
   *
   * It requires Prometheus >= v2.28.0.
   *
   * @schema ServiceMonitorSpec#bodySizeLimit
   */
  readonly bodySizeLimit?: string;

  /**
   * List of endpoints part of this ServiceMonitor.
   * Defines how to scrape metrics from Kubernetes [Endpoints](https://kubernetes.io/docs/concepts/services-networking/service/#endpoints) objects.
   * In most cases, an Endpoints object is backed by a Kubernetes [Service](https://kubernetes.io/docs/concepts/services-networking/service/) object with the same name and labels.
   *
   * @schema ServiceMonitorSpec#endpoints
   */
  readonly endpoints: ServiceMonitorSpecEndpoints[];

  /**
   * `jobLabel` selects the label from the associated Kubernetes `Service`
   * object which will be used as the `job` label for all metrics.
   *
   * For example if `jobLabel` is set to `foo` and the Kubernetes `Service`
   * object is labeled with `foo: bar`, then Prometheus adds the `job="bar"`
   * label to all ingested metrics.
   *
   * If the value of this field is empty or if the label doesn't exist for
   * the given Service, the `job` label of the metrics defaults to the name
   * of the associated Kubernetes `Service`.
   *
   * @schema ServiceMonitorSpec#jobLabel
   */
  readonly jobLabel?: string;

  /**
   * Per-scrape limit on the number of targets dropped by relabeling
   * that will be kept in memory. 0 means no limit.
   *
   * It requires Prometheus >= v2.47.0.
   *
   * @schema ServiceMonitorSpec#keepDroppedTargets
   */
  readonly keepDroppedTargets?: number;

  /**
   * Per-scrape limit on number of labels that will be accepted for a sample.
   *
   * It requires Prometheus >= v2.27.0.
   *
   * @schema ServiceMonitorSpec#labelLimit
   */
  readonly labelLimit?: number;

  /**
   * Per-scrape limit on length of labels name that will be accepted for a sample.
   *
   * It requires Prometheus >= v2.27.0.
   *
   * @schema ServiceMonitorSpec#labelNameLengthLimit
   */
  readonly labelNameLengthLimit?: number;

  /**
   * Per-scrape limit on length of labels value that will be accepted for a sample.
   *
   * It requires Prometheus >= v2.27.0.
   *
   * @schema ServiceMonitorSpec#labelValueLengthLimit
   */
  readonly labelValueLengthLimit?: number;

  /**
   * `namespaceSelector` defines in which namespace(s) Prometheus should discover the services.
   * By default, the services are discovered in the same namespace as the `ServiceMonitor` object but it is possible to select pods across different/all namespaces.
   *
   * @schema ServiceMonitorSpec#namespaceSelector
   */
  readonly namespaceSelector?: ServiceMonitorSpecNamespaceSelector;

  /**
   * If there are more than this many buckets in a native histogram,
   * buckets will be merged to stay within the limit.
   * It requires Prometheus >= v2.45.0.
   *
   * @schema ServiceMonitorSpec#nativeHistogramBucketLimit
   */
  readonly nativeHistogramBucketLimit?: number;

  /**
   * If the growth factor of one bucket to the next is smaller than this,
   * buckets will be merged to increase the factor sufficiently.
   * It requires Prometheus >= v2.50.0.
   *
   * @schema ServiceMonitorSpec#nativeHistogramMinBucketFactor
   */
  readonly nativeHistogramMinBucketFactor?: ServiceMonitorSpecNativeHistogramMinBucketFactor;

  /**
   * `podTargetLabels` defines the labels which are transferred from the
   * associated Kubernetes `Pod` object onto the ingested metrics.
   *
   * @schema ServiceMonitorSpec#podTargetLabels
   */
  readonly podTargetLabels?: string[];

  /**
   * `sampleLimit` defines a per-scrape limit on the number of scraped samples
   * that will be accepted.
   *
   * @schema ServiceMonitorSpec#sampleLimit
   */
  readonly sampleLimit?: number;

  /**
   * The scrape class to apply.
   *
   * @schema ServiceMonitorSpec#scrapeClass
   */
  readonly scrapeClass?: string;

  /**
   * Whether to scrape a classic histogram that is also exposed as a native histogram.
   * It requires Prometheus >= v2.45.0.
   *
   * @schema ServiceMonitorSpec#scrapeClassicHistograms
   */
  readonly scrapeClassicHistograms?: boolean;

  /**
   * `scrapeProtocols` defines the protocols to negotiate during a scrape. It tells clients the
   * protocols supported by Prometheus in order of preference (from most to least preferred).
   *
   * If unset, Prometheus uses its default value.
   *
   * It requires Prometheus >= v2.49.0.
   *
   * @schema ServiceMonitorSpec#scrapeProtocols
   */
  readonly scrapeProtocols?: ServiceMonitorSpecScrapeProtocols[];

  /**
   * Label selector to select the Kubernetes `Endpoints` objects to scrape metrics from.
   *
   * @schema ServiceMonitorSpec#selector
   */
  readonly selector: ServiceMonitorSpecSelector;

  /**
   * `targetLabels` defines the labels which are transferred from the
   * associated Kubernetes `Service` object onto the ingested metrics.
   *
   * @schema ServiceMonitorSpec#targetLabels
   */
  readonly targetLabels?: string[];

  /**
   * `targetLimit` defines a limit on the number of scraped targets that will
   * be accepted.
   *
   * @schema ServiceMonitorSpec#targetLimit
   */
  readonly targetLimit?: number;

}

/**
 * Converts an object of type 'ServiceMonitorSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpec(obj: ServiceMonitorSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attachMetadata': toJson_ServiceMonitorSpecAttachMetadata(obj.attachMetadata),
    'bodySizeLimit': obj.bodySizeLimit,
    'endpoints': obj.endpoints?.map(y => toJson_ServiceMonitorSpecEndpoints(y)),
    'jobLabel': obj.jobLabel,
    'keepDroppedTargets': obj.keepDroppedTargets,
    'labelLimit': obj.labelLimit,
    'labelNameLengthLimit': obj.labelNameLengthLimit,
    'labelValueLengthLimit': obj.labelValueLengthLimit,
    'namespaceSelector': toJson_ServiceMonitorSpecNamespaceSelector(obj.namespaceSelector),
    'nativeHistogramBucketLimit': obj.nativeHistogramBucketLimit,
    'nativeHistogramMinBucketFactor': obj.nativeHistogramMinBucketFactor?.value,
    'podTargetLabels': obj.podTargetLabels?.map(y => y),
    'sampleLimit': obj.sampleLimit,
    'scrapeClass': obj.scrapeClass,
    'scrapeClassicHistograms': obj.scrapeClassicHistograms,
    'scrapeProtocols': obj.scrapeProtocols?.map(y => y),
    'selector': toJson_ServiceMonitorSpecSelector(obj.selector),
    'targetLabels': obj.targetLabels?.map(y => y),
    'targetLimit': obj.targetLimit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `attachMetadata` defines additional metadata which is added to the
 * discovered targets.
 *
 * It requires Prometheus >= v2.37.0.
 *
 * @schema ServiceMonitorSpecAttachMetadata
 */
export interface ServiceMonitorSpecAttachMetadata {
  /**
   * When set to true, Prometheus attaches node metadata to the discovered
   * targets.
   *
   * The Prometheus service account must have the `list` and `watch`
   * permissions on the `Nodes` objects.
   *
   * @schema ServiceMonitorSpecAttachMetadata#node
   */
  readonly node?: boolean;

}

/**
 * Converts an object of type 'ServiceMonitorSpecAttachMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecAttachMetadata(obj: ServiceMonitorSpecAttachMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'node': obj.node,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Endpoint defines an endpoint serving Prometheus metrics to be scraped by
 * Prometheus.
 *
 * @schema ServiceMonitorSpecEndpoints
 */
export interface ServiceMonitorSpecEndpoints {
  /**
   * `authorization` configures the Authorization header credentials to use when
   * scraping the target.
   *
   * Cannot be set at the same time as `basicAuth`, or `oauth2`.
   *
   * @schema ServiceMonitorSpecEndpoints#authorization
   */
  readonly authorization?: ServiceMonitorSpecEndpointsAuthorization;

  /**
   * `basicAuth` configures the Basic Authentication credentials to use when
   * scraping the target.
   *
   * Cannot be set at the same time as `authorization`, or `oauth2`.
   *
   * @schema ServiceMonitorSpecEndpoints#basicAuth
   */
  readonly basicAuth?: ServiceMonitorSpecEndpointsBasicAuth;

  /**
   * File to read bearer token for scraping the target.
   *
   * Deprecated: use `authorization` instead.
   *
   * @schema ServiceMonitorSpecEndpoints#bearerTokenFile
   */
  readonly bearerTokenFile?: string;

  /**
   * `bearerTokenSecret` specifies a key of a Secret containing the bearer
   * token for scraping targets. The secret needs to be in the same namespace
   * as the ServiceMonitor object and readable by the Prometheus Operator.
   *
   * Deprecated: use `authorization` instead.
   *
   * @schema ServiceMonitorSpecEndpoints#bearerTokenSecret
   */
  readonly bearerTokenSecret?: ServiceMonitorSpecEndpointsBearerTokenSecret;

  /**
   * `enableHttp2` can be used to disable HTTP2 when scraping the target.
   *
   * @schema ServiceMonitorSpecEndpoints#enableHttp2
   */
  readonly enableHttp2?: boolean;

  /**
   * When true, the pods which are not running (e.g. either in Failed or
   * Succeeded state) are dropped during the target discovery.
   *
   * If unset, the filtering is enabled.
   *
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase
   *
   * @schema ServiceMonitorSpecEndpoints#filterRunning
   */
  readonly filterRunning?: boolean;

  /**
   * `followRedirects` defines whether the scrape requests should follow HTTP
   * 3xx redirects.
   *
   * @schema ServiceMonitorSpecEndpoints#followRedirects
   */
  readonly followRedirects?: boolean;

  /**
   * When true, `honorLabels` preserves the metric's labels when they collide
   * with the target's labels.
   *
   * @schema ServiceMonitorSpecEndpoints#honorLabels
   */
  readonly honorLabels?: boolean;

  /**
   * `honorTimestamps` controls whether Prometheus preserves the timestamps
   * when exposed by the target.
   *
   * @schema ServiceMonitorSpecEndpoints#honorTimestamps
   */
  readonly honorTimestamps?: boolean;

  /**
   * Interval at which Prometheus scrapes the metrics from the target.
   *
   * If empty, Prometheus uses the global scrape interval.
   *
   * @schema ServiceMonitorSpecEndpoints#interval
   */
  readonly interval?: string;

  /**
   * `metricRelabelings` configures the relabeling rules to apply to the
   * samples before ingestion.
   *
   * @schema ServiceMonitorSpecEndpoints#metricRelabelings
   */
  readonly metricRelabelings?: ServiceMonitorSpecEndpointsMetricRelabelings[];

  /**
   * `oauth2` configures the OAuth2 settings to use when scraping the target.
   *
   * It requires Prometheus >= 2.27.0.
   *
   * Cannot be set at the same time as `authorization`, or `basicAuth`.
   *
   * @schema ServiceMonitorSpecEndpoints#oauth2
   */
  readonly oauth2?: ServiceMonitorSpecEndpointsOauth2;

  /**
   * params define optional HTTP URL parameters.
   *
   * @schema ServiceMonitorSpecEndpoints#params
   */
  readonly params?: { [key: string]: string[] };

  /**
   * HTTP path from which to scrape for metrics.
   *
   * If empty, Prometheus uses the default value (e.g. `/metrics`).
   *
   * @schema ServiceMonitorSpecEndpoints#path
   */
  readonly path?: string;

  /**
   * Name of the Service port which this endpoint refers to.
   *
   * It takes precedence over `targetPort`.
   *
   * @schema ServiceMonitorSpecEndpoints#port
   */
  readonly port?: string;

  /**
   * `proxyURL` configures the HTTP Proxy URL (e.g.
   * "http://proxyserver:2195") to go through when scraping the target.
   *
   * @schema ServiceMonitorSpecEndpoints#proxyUrl
   */
  readonly proxyUrl?: string;

  /**
   * `relabelings` configures the relabeling rules to apply the target's
   * metadata labels.
   *
   * The Operator automatically adds relabelings for a few standard Kubernetes fields.
   *
   * The original scrape job's name is available via the `__tmp_prometheus_job_name` label.
   *
   * More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
   *
   * @schema ServiceMonitorSpecEndpoints#relabelings
   */
  readonly relabelings?: ServiceMonitorSpecEndpointsRelabelings[];

  /**
   * HTTP scheme to use for scraping.
   *
   * `http` and `https` are the expected values unless you rewrite the
   * `__scheme__` label via relabeling.
   *
   * If empty, Prometheus uses the default value `http`.
   *
   * @schema ServiceMonitorSpecEndpoints#scheme
   */
  readonly scheme?: ServiceMonitorSpecEndpointsScheme;

  /**
   * Timeout after which Prometheus considers the scrape to be failed.
   *
   * If empty, Prometheus uses the global scrape timeout unless it is less
   * than the target's scrape interval value in which the latter is used.
   *
   * @schema ServiceMonitorSpecEndpoints#scrapeTimeout
   */
  readonly scrapeTimeout?: string;

  /**
   * Name or number of the target port of the `Pod` object behind the
   * Service. The port must be specified with the container's port property.
   *
   * @schema ServiceMonitorSpecEndpoints#targetPort
   */
  readonly targetPort?: ServiceMonitorSpecEndpointsTargetPort;

  /**
   * TLS configuration to use when scraping the target.
   *
   * @schema ServiceMonitorSpecEndpoints#tlsConfig
   */
  readonly tlsConfig?: ServiceMonitorSpecEndpointsTlsConfig;

  /**
   * `trackTimestampsStaleness` defines whether Prometheus tracks staleness of
   * the metrics that have an explicit timestamp present in scraped data.
   * Has no effect if `honorTimestamps` is false.
   *
   * It requires Prometheus >= v2.48.0.
   *
   * @schema ServiceMonitorSpecEndpoints#trackTimestampsStaleness
   */
  readonly trackTimestampsStaleness?: boolean;

}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpoints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpoints(obj: ServiceMonitorSpecEndpoints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorization': toJson_ServiceMonitorSpecEndpointsAuthorization(obj.authorization),
    'basicAuth': toJson_ServiceMonitorSpecEndpointsBasicAuth(obj.basicAuth),
    'bearerTokenFile': obj.bearerTokenFile,
    'bearerTokenSecret': toJson_ServiceMonitorSpecEndpointsBearerTokenSecret(obj.bearerTokenSecret),
    'enableHttp2': obj.enableHttp2,
    'filterRunning': obj.filterRunning,
    'followRedirects': obj.followRedirects,
    'honorLabels': obj.honorLabels,
    'honorTimestamps': obj.honorTimestamps,
    'interval': obj.interval,
    'metricRelabelings': obj.metricRelabelings?.map(y => toJson_ServiceMonitorSpecEndpointsMetricRelabelings(y)),
    'oauth2': toJson_ServiceMonitorSpecEndpointsOauth2(obj.oauth2),
    'params': ((obj.params) === undefined) ? undefined : (Object.entries(obj.params).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.map(y => y) }), {})),
    'path': obj.path,
    'port': obj.port,
    'proxyUrl': obj.proxyUrl,
    'relabelings': obj.relabelings?.map(y => toJson_ServiceMonitorSpecEndpointsRelabelings(y)),
    'scheme': obj.scheme,
    'scrapeTimeout': obj.scrapeTimeout,
    'targetPort': obj.targetPort?.value,
    'tlsConfig': toJson_ServiceMonitorSpecEndpointsTlsConfig(obj.tlsConfig),
    'trackTimestampsStaleness': obj.trackTimestampsStaleness,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `namespaceSelector` defines in which namespace(s) Prometheus should discover the services.
 * By default, the services are discovered in the same namespace as the `ServiceMonitor` object but it is possible to select pods across different/all namespaces.
 *
 * @schema ServiceMonitorSpecNamespaceSelector
 */
export interface ServiceMonitorSpecNamespaceSelector {
  /**
   * Boolean describing whether all namespaces are selected in contrast to a
   * list restricting them.
   *
   * @schema ServiceMonitorSpecNamespaceSelector#any
   */
  readonly any?: boolean;

  /**
   * List of namespace names to select from.
   *
   * @schema ServiceMonitorSpecNamespaceSelector#matchNames
   */
  readonly matchNames?: string[];

}

/**
 * Converts an object of type 'ServiceMonitorSpecNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecNamespaceSelector(obj: ServiceMonitorSpecNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'any': obj.any,
    'matchNames': obj.matchNames?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * If the growth factor of one bucket to the next is smaller than this,
 * buckets will be merged to increase the factor sufficiently.
 * It requires Prometheus >= v2.50.0.
 *
 * @schema ServiceMonitorSpecNativeHistogramMinBucketFactor
 */
export class ServiceMonitorSpecNativeHistogramMinBucketFactor {
  public static fromNumber(value: number): ServiceMonitorSpecNativeHistogramMinBucketFactor {
    return new ServiceMonitorSpecNativeHistogramMinBucketFactor(value);
  }
  public static fromString(value: string): ServiceMonitorSpecNativeHistogramMinBucketFactor {
    return new ServiceMonitorSpecNativeHistogramMinBucketFactor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * ScrapeProtocol represents a protocol used by Prometheus for scraping metrics.
 * Supported values are:
 * * `OpenMetricsText0.0.1`
 * * `OpenMetricsText1.0.0`
 * * `PrometheusProto`
 * * `PrometheusText0.0.4`
 *
 * @schema ServiceMonitorSpecScrapeProtocols
 */
export enum ServiceMonitorSpecScrapeProtocols {
  /** PrometheusProto */
  PROMETHEUS_PROTO = "PrometheusProto",
  /** OpenMetricsText0.0.1 */
  OPEN_METRICS_TEXT0_0_1 = "OpenMetricsText0.0.1",
  /** OpenMetricsText1.0.0 */
  OPEN_METRICS_TEXT1_0_0 = "OpenMetricsText1.0.0",
  /** PrometheusText0.0.4 */
  PROMETHEUS_TEXT0_0_4 = "PrometheusText0.0.4",
}

/**
 * Label selector to select the Kubernetes `Endpoints` objects to scrape metrics from.
 *
 * @schema ServiceMonitorSpecSelector
 */
export interface ServiceMonitorSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ServiceMonitorSpecSelector#matchExpressions
   */
  readonly matchExpressions?: ServiceMonitorSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ServiceMonitorSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ServiceMonitorSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecSelector(obj: ServiceMonitorSpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ServiceMonitorSpecSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `authorization` configures the Authorization header credentials to use when
 * scraping the target.
 *
 * Cannot be set at the same time as `basicAuth`, or `oauth2`.
 *
 * @schema ServiceMonitorSpecEndpointsAuthorization
 */
export interface ServiceMonitorSpecEndpointsAuthorization {
  /**
   * Selects a key of a Secret in the namespace that contains the credentials for authentication.
   *
   * @schema ServiceMonitorSpecEndpointsAuthorization#credentials
   */
  readonly credentials?: ServiceMonitorSpecEndpointsAuthorizationCredentials;

  /**
   * Defines the authentication type. The value is case-insensitive.
   *
   * "Basic" is not a supported value.
   *
   * Default: "Bearer"
   *
   * @schema ServiceMonitorSpecEndpointsAuthorization#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsAuthorization(obj: ServiceMonitorSpecEndpointsAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_ServiceMonitorSpecEndpointsAuthorizationCredentials(obj.credentials),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `basicAuth` configures the Basic Authentication credentials to use when
 * scraping the target.
 *
 * Cannot be set at the same time as `authorization`, or `oauth2`.
 *
 * @schema ServiceMonitorSpecEndpointsBasicAuth
 */
export interface ServiceMonitorSpecEndpointsBasicAuth {
  /**
   * `password` specifies a key of a Secret containing the password for
   * authentication.
   *
   * @schema ServiceMonitorSpecEndpointsBasicAuth#password
   */
  readonly password?: ServiceMonitorSpecEndpointsBasicAuthPassword;

  /**
   * `username` specifies a key of a Secret containing the username for
   * authentication.
   *
   * @schema ServiceMonitorSpecEndpointsBasicAuth#username
   */
  readonly username?: ServiceMonitorSpecEndpointsBasicAuthUsername;

}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsBasicAuth(obj: ServiceMonitorSpecEndpointsBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_ServiceMonitorSpecEndpointsBasicAuthPassword(obj.password),
    'username': toJson_ServiceMonitorSpecEndpointsBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `bearerTokenSecret` specifies a key of a Secret containing the bearer
 * token for scraping targets. The secret needs to be in the same namespace
 * as the ServiceMonitor object and readable by the Prometheus Operator.
 *
 * Deprecated: use `authorization` instead.
 *
 * @schema ServiceMonitorSpecEndpointsBearerTokenSecret
 */
export interface ServiceMonitorSpecEndpointsBearerTokenSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ServiceMonitorSpecEndpointsBearerTokenSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ServiceMonitorSpecEndpointsBearerTokenSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ServiceMonitorSpecEndpointsBearerTokenSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsBearerTokenSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsBearerTokenSecret(obj: ServiceMonitorSpecEndpointsBearerTokenSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RelabelConfig allows dynamic rewriting of the label set for targets, alerts,
 * scraped samples and remote write samples.
 *
 * More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
 *
 * @schema ServiceMonitorSpecEndpointsMetricRelabelings
 */
export interface ServiceMonitorSpecEndpointsMetricRelabelings {
  /**
   * Action to perform based on the regex matching.
   *
   * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.
   * `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
   *
   * Default: "Replace"
   *
   * @schema ServiceMonitorSpecEndpointsMetricRelabelings#action
   */
  readonly action?: ServiceMonitorSpecEndpointsMetricRelabelingsAction;

  /**
   * Modulus to take of the hash of the source label values.
   *
   * Only applicable when the action is `HashMod`.
   *
   * @schema ServiceMonitorSpecEndpointsMetricRelabelings#modulus
   */
  readonly modulus?: number;

  /**
   * Regular expression against which the extracted value is matched.
   *
   * @schema ServiceMonitorSpecEndpointsMetricRelabelings#regex
   */
  readonly regex?: string;

  /**
   * Replacement value against which a Replace action is performed if the
   * regular expression matches.
   *
   * Regex capture groups are available.
   *
   * @schema ServiceMonitorSpecEndpointsMetricRelabelings#replacement
   */
  readonly replacement?: string;

  /**
   * Separator is the string between concatenated SourceLabels.
   *
   * @schema ServiceMonitorSpecEndpointsMetricRelabelings#separator
   */
  readonly separator?: string;

  /**
   * The source labels select values from existing labels. Their content is
   * concatenated using the configured Separator and matched against the
   * configured regular expression.
   *
   * @schema ServiceMonitorSpecEndpointsMetricRelabelings#sourceLabels
   */
  readonly sourceLabels?: string[];

  /**
   * Label to which the resulting string is written in a replacement.
   *
   * It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`,
   * `KeepEqual` and `DropEqual` actions.
   *
   * Regex capture groups are available.
   *
   * @schema ServiceMonitorSpecEndpointsMetricRelabelings#targetLabel
   */
  readonly targetLabel?: string;

}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsMetricRelabelings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsMetricRelabelings(obj: ServiceMonitorSpecEndpointsMetricRelabelings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'modulus': obj.modulus,
    'regex': obj.regex,
    'replacement': obj.replacement,
    'separator': obj.separator,
    'sourceLabels': obj.sourceLabels?.map(y => y),
    'targetLabel': obj.targetLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `oauth2` configures the OAuth2 settings to use when scraping the target.
 *
 * It requires Prometheus >= 2.27.0.
 *
 * Cannot be set at the same time as `authorization`, or `basicAuth`.
 *
 * @schema ServiceMonitorSpecEndpointsOauth2
 */
export interface ServiceMonitorSpecEndpointsOauth2 {
  /**
   * `clientId` specifies a key of a Secret or ConfigMap containing the
   * OAuth2 client's ID.
   *
   * @schema ServiceMonitorSpecEndpointsOauth2#clientId
   */
  readonly clientId: ServiceMonitorSpecEndpointsOauth2ClientId;

  /**
   * `clientSecret` specifies a key of a Secret containing the OAuth2
   * client's secret.
   *
   * @schema ServiceMonitorSpecEndpointsOauth2#clientSecret
   */
  readonly clientSecret: ServiceMonitorSpecEndpointsOauth2ClientSecret;

  /**
   * `endpointParams` configures the HTTP parameters to append to the token
   * URL.
   *
   * @schema ServiceMonitorSpecEndpointsOauth2#endpointParams
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names
   * that should be excluded from proxying. IP and domain names can
   * contain port numbers.
   *
   * It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
   *
   * @schema ServiceMonitorSpecEndpointsOauth2#noProxy
   */
  readonly noProxy?: string;

  /**
   * ProxyConnectHeader optionally specifies headers to send to
   * proxies during CONNECT requests.
   *
   * It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
   *
   * @schema ServiceMonitorSpecEndpointsOauth2#proxyConnectHeader
   */
  readonly proxyConnectHeader?: { [key: string]: ServiceMonitorSpecEndpointsOauth2ProxyConnectHeader[] };

  /**
   * Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
   *
   * It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
   *
   * @schema ServiceMonitorSpecEndpointsOauth2#proxyFromEnvironment
   */
  readonly proxyFromEnvironment?: boolean;

  /**
   * `proxyURL` defines the HTTP proxy server to use.
   *
   * @schema ServiceMonitorSpecEndpointsOauth2#proxyUrl
   */
  readonly proxyUrl?: string;

  /**
   * `scopes` defines the OAuth2 scopes used for the token request.
   *
   * @schema ServiceMonitorSpecEndpointsOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * TLS configuration to use when connecting to the OAuth2 server.
   * It requires Prometheus >= v2.43.0.
   *
   * @schema ServiceMonitorSpecEndpointsOauth2#tlsConfig
   */
  readonly tlsConfig?: ServiceMonitorSpecEndpointsOauth2TlsConfig;

  /**
   * `tokenURL` configures the URL to fetch the token from.
   *
   * @schema ServiceMonitorSpecEndpointsOauth2#tokenUrl
   */
  readonly tokenUrl: string;

}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsOauth2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsOauth2(obj: ServiceMonitorSpecEndpointsOauth2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientId': toJson_ServiceMonitorSpecEndpointsOauth2ClientId(obj.clientId),
    'clientSecret': toJson_ServiceMonitorSpecEndpointsOauth2ClientSecret(obj.clientSecret),
    'endpointParams': ((obj.endpointParams) === undefined) ? undefined : (Object.entries(obj.endpointParams).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'noProxy': obj.noProxy,
    'proxyConnectHeader': ((obj.proxyConnectHeader) === undefined) ? undefined : (Object.entries(obj.proxyConnectHeader).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.map(y => toJson_ServiceMonitorSpecEndpointsOauth2ProxyConnectHeader(y)) }), {})),
    'proxyFromEnvironment': obj.proxyFromEnvironment,
    'proxyUrl': obj.proxyUrl,
    'scopes': obj.scopes?.map(y => y),
    'tlsConfig': toJson_ServiceMonitorSpecEndpointsOauth2TlsConfig(obj.tlsConfig),
    'tokenUrl': obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RelabelConfig allows dynamic rewriting of the label set for targets, alerts,
 * scraped samples and remote write samples.
 *
 * More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
 *
 * @schema ServiceMonitorSpecEndpointsRelabelings
 */
export interface ServiceMonitorSpecEndpointsRelabelings {
  /**
   * Action to perform based on the regex matching.
   *
   * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.
   * `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
   *
   * Default: "Replace"
   *
   * @schema ServiceMonitorSpecEndpointsRelabelings#action
   */
  readonly action?: ServiceMonitorSpecEndpointsRelabelingsAction;

  /**
   * Modulus to take of the hash of the source label values.
   *
   * Only applicable when the action is `HashMod`.
   *
   * @schema ServiceMonitorSpecEndpointsRelabelings#modulus
   */
  readonly modulus?: number;

  /**
   * Regular expression against which the extracted value is matched.
   *
   * @schema ServiceMonitorSpecEndpointsRelabelings#regex
   */
  readonly regex?: string;

  /**
   * Replacement value against which a Replace action is performed if the
   * regular expression matches.
   *
   * Regex capture groups are available.
   *
   * @schema ServiceMonitorSpecEndpointsRelabelings#replacement
   */
  readonly replacement?: string;

  /**
   * Separator is the string between concatenated SourceLabels.
   *
   * @schema ServiceMonitorSpecEndpointsRelabelings#separator
   */
  readonly separator?: string;

  /**
   * The source labels select values from existing labels. Their content is
   * concatenated using the configured Separator and matched against the
   * configured regular expression.
   *
   * @schema ServiceMonitorSpecEndpointsRelabelings#sourceLabels
   */
  readonly sourceLabels?: string[];

  /**
   * Label to which the resulting string is written in a replacement.
   *
   * It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`,
   * `KeepEqual` and `DropEqual` actions.
   *
   * Regex capture groups are available.
   *
   * @schema ServiceMonitorSpecEndpointsRelabelings#targetLabel
   */
  readonly targetLabel?: string;

}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsRelabelings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsRelabelings(obj: ServiceMonitorSpecEndpointsRelabelings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'modulus': obj.modulus,
    'regex': obj.regex,
    'replacement': obj.replacement,
    'separator': obj.separator,
    'sourceLabels': obj.sourceLabels?.map(y => y),
    'targetLabel': obj.targetLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTP scheme to use for scraping.
 *
 * `http` and `https` are the expected values unless you rewrite the
 * `__scheme__` label via relabeling.
 *
 * If empty, Prometheus uses the default value `http`.
 *
 * @schema ServiceMonitorSpecEndpointsScheme
 */
export enum ServiceMonitorSpecEndpointsScheme {
  /** http */
  HTTP = "http",
  /** https */
  HTTPS = "https",
}

/**
 * Name or number of the target port of the `Pod` object behind the
 * Service. The port must be specified with the container's port property.
 *
 * @schema ServiceMonitorSpecEndpointsTargetPort
 */
export class ServiceMonitorSpecEndpointsTargetPort {
  public static fromNumber(value: number): ServiceMonitorSpecEndpointsTargetPort {
    return new ServiceMonitorSpecEndpointsTargetPort(value);
  }
  public static fromString(value: string): ServiceMonitorSpecEndpointsTargetPort {
    return new ServiceMonitorSpecEndpointsTargetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * TLS configuration to use when scraping the target.
 *
 * @schema ServiceMonitorSpecEndpointsTlsConfig
 */
export interface ServiceMonitorSpecEndpointsTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfig#ca
   */
  readonly ca?: ServiceMonitorSpecEndpointsTlsConfigCa;

  /**
   * Path to the CA cert in the Prometheus container to use for the targets.
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfig#caFile
   */
  readonly caFile?: string;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfig#cert
   */
  readonly cert?: ServiceMonitorSpecEndpointsTlsConfigCert;

  /**
   * Path to the client cert file in the Prometheus container for the targets.
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfig#certFile
   */
  readonly certFile?: string;

  /**
   * Disable target certificate validation.
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Path to the client key file in the Prometheus container for the targets.
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfig#keyFile
   */
  readonly keyFile?: string;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfig#keySecret
   */
  readonly keySecret?: ServiceMonitorSpecEndpointsTlsConfigKeySecret;

  /**
   * Maximum acceptable TLS version.
   *
   * It requires Prometheus >= v2.41.0.
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfig#maxVersion
   */
  readonly maxVersion?: ServiceMonitorSpecEndpointsTlsConfigMaxVersion;

  /**
   * Minimum acceptable TLS version.
   *
   * It requires Prometheus >= v2.35.0.
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfig#minVersion
   */
  readonly minVersion?: ServiceMonitorSpecEndpointsTlsConfigMinVersion;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsTlsConfig(obj: ServiceMonitorSpecEndpointsTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_ServiceMonitorSpecEndpointsTlsConfigCa(obj.ca),
    'caFile': obj.caFile,
    'cert': toJson_ServiceMonitorSpecEndpointsTlsConfigCert(obj.cert),
    'certFile': obj.certFile,
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keyFile': obj.keyFile,
    'keySecret': toJson_ServiceMonitorSpecEndpointsTlsConfigKeySecret(obj.keySecret),
    'maxVersion': obj.maxVersion,
    'minVersion': obj.minVersion,
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ServiceMonitorSpecSelectorMatchExpressions
 */
export interface ServiceMonitorSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ServiceMonitorSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ServiceMonitorSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ServiceMonitorSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ServiceMonitorSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecSelectorMatchExpressions(obj: ServiceMonitorSpecSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a Secret in the namespace that contains the credentials for authentication.
 *
 * @schema ServiceMonitorSpecEndpointsAuthorizationCredentials
 */
export interface ServiceMonitorSpecEndpointsAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ServiceMonitorSpecEndpointsAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ServiceMonitorSpecEndpointsAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ServiceMonitorSpecEndpointsAuthorizationCredentials#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsAuthorizationCredentials(obj: ServiceMonitorSpecEndpointsAuthorizationCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `password` specifies a key of a Secret containing the password for
 * authentication.
 *
 * @schema ServiceMonitorSpecEndpointsBasicAuthPassword
 */
export interface ServiceMonitorSpecEndpointsBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ServiceMonitorSpecEndpointsBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ServiceMonitorSpecEndpointsBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ServiceMonitorSpecEndpointsBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsBasicAuthPassword(obj: ServiceMonitorSpecEndpointsBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `username` specifies a key of a Secret containing the username for
 * authentication.
 *
 * @schema ServiceMonitorSpecEndpointsBasicAuthUsername
 */
export interface ServiceMonitorSpecEndpointsBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ServiceMonitorSpecEndpointsBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ServiceMonitorSpecEndpointsBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ServiceMonitorSpecEndpointsBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsBasicAuthUsername(obj: ServiceMonitorSpecEndpointsBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Action to perform based on the regex matching.
 *
 * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.
 * `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
 *
 * Default: "Replace"
 *
 * @schema ServiceMonitorSpecEndpointsMetricRelabelingsAction
 */
export enum ServiceMonitorSpecEndpointsMetricRelabelingsAction {
  /** replace */
  REPLACE = "replace",
  /** keep */
  KEEP = "keep",
  /** drop */
  DROP = "drop",
  /** hashmod */
  HASHMOD = "hashmod",
  /** labelmap */
  LABELMAP = "labelmap",
  /** labeldrop */
  LABELDROP = "labeldrop",
  /** labelkeep */
  LABELKEEP = "labelkeep",
  /** lowercase */
  LOWERCASE = "lowercase",
  /** uppercase */
  UPPERCASE = "uppercase",
  /** keepequal */
  KEEPEQUAL = "keepequal",
  /** dropequal */
  DROPEQUAL = "dropequal",
}

/**
 * `clientId` specifies a key of a Secret or ConfigMap containing the
 * OAuth2 client's ID.
 *
 * @schema ServiceMonitorSpecEndpointsOauth2ClientId
 */
export interface ServiceMonitorSpecEndpointsOauth2ClientId {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema ServiceMonitorSpecEndpointsOauth2ClientId#configMap
   */
  readonly configMap?: ServiceMonitorSpecEndpointsOauth2ClientIdConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema ServiceMonitorSpecEndpointsOauth2ClientId#secret
   */
  readonly secret?: ServiceMonitorSpecEndpointsOauth2ClientIdSecret;

}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsOauth2ClientId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsOauth2ClientId(obj: ServiceMonitorSpecEndpointsOauth2ClientId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_ServiceMonitorSpecEndpointsOauth2ClientIdConfigMap(obj.configMap),
    'secret': toJson_ServiceMonitorSpecEndpointsOauth2ClientIdSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `clientSecret` specifies a key of a Secret containing the OAuth2
 * client's secret.
 *
 * @schema ServiceMonitorSpecEndpointsOauth2ClientSecret
 */
export interface ServiceMonitorSpecEndpointsOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ServiceMonitorSpecEndpointsOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ServiceMonitorSpecEndpointsOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ServiceMonitorSpecEndpointsOauth2ClientSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsOauth2ClientSecret(obj: ServiceMonitorSpecEndpointsOauth2ClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ServiceMonitorSpecEndpointsOauth2ProxyConnectHeader
 */
export interface ServiceMonitorSpecEndpointsOauth2ProxyConnectHeader {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ServiceMonitorSpecEndpointsOauth2ProxyConnectHeader#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ServiceMonitorSpecEndpointsOauth2ProxyConnectHeader#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ServiceMonitorSpecEndpointsOauth2ProxyConnectHeader#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsOauth2ProxyConnectHeader' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsOauth2ProxyConnectHeader(obj: ServiceMonitorSpecEndpointsOauth2ProxyConnectHeader | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS configuration to use when connecting to the OAuth2 server.
 * It requires Prometheus >= v2.43.0.
 *
 * @schema ServiceMonitorSpecEndpointsOauth2TlsConfig
 */
export interface ServiceMonitorSpecEndpointsOauth2TlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema ServiceMonitorSpecEndpointsOauth2TlsConfig#ca
   */
  readonly ca?: ServiceMonitorSpecEndpointsOauth2TlsConfigCa;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema ServiceMonitorSpecEndpointsOauth2TlsConfig#cert
   */
  readonly cert?: ServiceMonitorSpecEndpointsOauth2TlsConfigCert;

  /**
   * Disable target certificate validation.
   *
   * @schema ServiceMonitorSpecEndpointsOauth2TlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema ServiceMonitorSpecEndpointsOauth2TlsConfig#keySecret
   */
  readonly keySecret?: ServiceMonitorSpecEndpointsOauth2TlsConfigKeySecret;

  /**
   * Maximum acceptable TLS version.
   *
   * It requires Prometheus >= v2.41.0.
   *
   * @schema ServiceMonitorSpecEndpointsOauth2TlsConfig#maxVersion
   */
  readonly maxVersion?: ServiceMonitorSpecEndpointsOauth2TlsConfigMaxVersion;

  /**
   * Minimum acceptable TLS version.
   *
   * It requires Prometheus >= v2.35.0.
   *
   * @schema ServiceMonitorSpecEndpointsOauth2TlsConfig#minVersion
   */
  readonly minVersion?: ServiceMonitorSpecEndpointsOauth2TlsConfigMinVersion;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema ServiceMonitorSpecEndpointsOauth2TlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsOauth2TlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsOauth2TlsConfig(obj: ServiceMonitorSpecEndpointsOauth2TlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_ServiceMonitorSpecEndpointsOauth2TlsConfigCa(obj.ca),
    'cert': toJson_ServiceMonitorSpecEndpointsOauth2TlsConfigCert(obj.cert),
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keySecret': toJson_ServiceMonitorSpecEndpointsOauth2TlsConfigKeySecret(obj.keySecret),
    'maxVersion': obj.maxVersion,
    'minVersion': obj.minVersion,
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Action to perform based on the regex matching.
 *
 * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.
 * `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
 *
 * Default: "Replace"
 *
 * @schema ServiceMonitorSpecEndpointsRelabelingsAction
 */
export enum ServiceMonitorSpecEndpointsRelabelingsAction {
  /** replace */
  REPLACE = "replace",
  /** keep */
  KEEP = "keep",
  /** drop */
  DROP = "drop",
  /** hashmod */
  HASHMOD = "hashmod",
  /** labelmap */
  LABELMAP = "labelmap",
  /** labeldrop */
  LABELDROP = "labeldrop",
  /** labelkeep */
  LABELKEEP = "labelkeep",
  /** lowercase */
  LOWERCASE = "lowercase",
  /** uppercase */
  UPPERCASE = "uppercase",
  /** keepequal */
  KEEPEQUAL = "keepequal",
  /** dropequal */
  DROPEQUAL = "dropequal",
}

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema ServiceMonitorSpecEndpointsTlsConfigCa
 */
export interface ServiceMonitorSpecEndpointsTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfigCa#configMap
   */
  readonly configMap?: ServiceMonitorSpecEndpointsTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfigCa#secret
   */
  readonly secret?: ServiceMonitorSpecEndpointsTlsConfigCaSecret;

}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsTlsConfigCa(obj: ServiceMonitorSpecEndpointsTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_ServiceMonitorSpecEndpointsTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_ServiceMonitorSpecEndpointsTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema ServiceMonitorSpecEndpointsTlsConfigCert
 */
export interface ServiceMonitorSpecEndpointsTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfigCert#configMap
   */
  readonly configMap?: ServiceMonitorSpecEndpointsTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfigCert#secret
   */
  readonly secret?: ServiceMonitorSpecEndpointsTlsConfigCertSecret;

}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsTlsConfigCert(obj: ServiceMonitorSpecEndpointsTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_ServiceMonitorSpecEndpointsTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_ServiceMonitorSpecEndpointsTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema ServiceMonitorSpecEndpointsTlsConfigKeySecret
 */
export interface ServiceMonitorSpecEndpointsTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsTlsConfigKeySecret(obj: ServiceMonitorSpecEndpointsTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maximum acceptable TLS version.
 *
 * It requires Prometheus >= v2.41.0.
 *
 * @schema ServiceMonitorSpecEndpointsTlsConfigMaxVersion
 */
export enum ServiceMonitorSpecEndpointsTlsConfigMaxVersion {
  /** TLS10 */
  TLS10 = "TLS10",
  /** TLS11 */
  TLS11 = "TLS11",
  /** TLS12 */
  TLS12 = "TLS12",
  /** TLS13 */
  TLS13 = "TLS13",
}

/**
 * Minimum acceptable TLS version.
 *
 * It requires Prometheus >= v2.35.0.
 *
 * @schema ServiceMonitorSpecEndpointsTlsConfigMinVersion
 */
export enum ServiceMonitorSpecEndpointsTlsConfigMinVersion {
  /** TLS10 */
  TLS10 = "TLS10",
  /** TLS11 */
  TLS11 = "TLS11",
  /** TLS12 */
  TLS12 = "TLS12",
  /** TLS13 */
  TLS13 = "TLS13",
}

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema ServiceMonitorSpecEndpointsOauth2ClientIdConfigMap
 */
export interface ServiceMonitorSpecEndpointsOauth2ClientIdConfigMap {
  /**
   * The key to select.
   *
   * @schema ServiceMonitorSpecEndpointsOauth2ClientIdConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ServiceMonitorSpecEndpointsOauth2ClientIdConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ServiceMonitorSpecEndpointsOauth2ClientIdConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsOauth2ClientIdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsOauth2ClientIdConfigMap(obj: ServiceMonitorSpecEndpointsOauth2ClientIdConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema ServiceMonitorSpecEndpointsOauth2ClientIdSecret
 */
export interface ServiceMonitorSpecEndpointsOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ServiceMonitorSpecEndpointsOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ServiceMonitorSpecEndpointsOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ServiceMonitorSpecEndpointsOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsOauth2ClientIdSecret(obj: ServiceMonitorSpecEndpointsOauth2ClientIdSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema ServiceMonitorSpecEndpointsOauth2TlsConfigCa
 */
export interface ServiceMonitorSpecEndpointsOauth2TlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema ServiceMonitorSpecEndpointsOauth2TlsConfigCa#configMap
   */
  readonly configMap?: ServiceMonitorSpecEndpointsOauth2TlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema ServiceMonitorSpecEndpointsOauth2TlsConfigCa#secret
   */
  readonly secret?: ServiceMonitorSpecEndpointsOauth2TlsConfigCaSecret;

}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsOauth2TlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsOauth2TlsConfigCa(obj: ServiceMonitorSpecEndpointsOauth2TlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_ServiceMonitorSpecEndpointsOauth2TlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_ServiceMonitorSpecEndpointsOauth2TlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema ServiceMonitorSpecEndpointsOauth2TlsConfigCert
 */
export interface ServiceMonitorSpecEndpointsOauth2TlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema ServiceMonitorSpecEndpointsOauth2TlsConfigCert#configMap
   */
  readonly configMap?: ServiceMonitorSpecEndpointsOauth2TlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema ServiceMonitorSpecEndpointsOauth2TlsConfigCert#secret
   */
  readonly secret?: ServiceMonitorSpecEndpointsOauth2TlsConfigCertSecret;

}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsOauth2TlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsOauth2TlsConfigCert(obj: ServiceMonitorSpecEndpointsOauth2TlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_ServiceMonitorSpecEndpointsOauth2TlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_ServiceMonitorSpecEndpointsOauth2TlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema ServiceMonitorSpecEndpointsOauth2TlsConfigKeySecret
 */
export interface ServiceMonitorSpecEndpointsOauth2TlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ServiceMonitorSpecEndpointsOauth2TlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ServiceMonitorSpecEndpointsOauth2TlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ServiceMonitorSpecEndpointsOauth2TlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsOauth2TlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsOauth2TlsConfigKeySecret(obj: ServiceMonitorSpecEndpointsOauth2TlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maximum acceptable TLS version.
 *
 * It requires Prometheus >= v2.41.0.
 *
 * @schema ServiceMonitorSpecEndpointsOauth2TlsConfigMaxVersion
 */
export enum ServiceMonitorSpecEndpointsOauth2TlsConfigMaxVersion {
  /** TLS10 */
  TLS10 = "TLS10",
  /** TLS11 */
  TLS11 = "TLS11",
  /** TLS12 */
  TLS12 = "TLS12",
  /** TLS13 */
  TLS13 = "TLS13",
}

/**
 * Minimum acceptable TLS version.
 *
 * It requires Prometheus >= v2.35.0.
 *
 * @schema ServiceMonitorSpecEndpointsOauth2TlsConfigMinVersion
 */
export enum ServiceMonitorSpecEndpointsOauth2TlsConfigMinVersion {
  /** TLS10 */
  TLS10 = "TLS10",
  /** TLS11 */
  TLS11 = "TLS11",
  /** TLS12 */
  TLS12 = "TLS12",
  /** TLS13 */
  TLS13 = "TLS13",
}

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema ServiceMonitorSpecEndpointsTlsConfigCaConfigMap
 */
export interface ServiceMonitorSpecEndpointsTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsTlsConfigCaConfigMap(obj: ServiceMonitorSpecEndpointsTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema ServiceMonitorSpecEndpointsTlsConfigCaSecret
 */
export interface ServiceMonitorSpecEndpointsTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsTlsConfigCaSecret(obj: ServiceMonitorSpecEndpointsTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema ServiceMonitorSpecEndpointsTlsConfigCertConfigMap
 */
export interface ServiceMonitorSpecEndpointsTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsTlsConfigCertConfigMap(obj: ServiceMonitorSpecEndpointsTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema ServiceMonitorSpecEndpointsTlsConfigCertSecret
 */
export interface ServiceMonitorSpecEndpointsTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsTlsConfigCertSecret(obj: ServiceMonitorSpecEndpointsTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema ServiceMonitorSpecEndpointsOauth2TlsConfigCaConfigMap
 */
export interface ServiceMonitorSpecEndpointsOauth2TlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema ServiceMonitorSpecEndpointsOauth2TlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ServiceMonitorSpecEndpointsOauth2TlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ServiceMonitorSpecEndpointsOauth2TlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsOauth2TlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsOauth2TlsConfigCaConfigMap(obj: ServiceMonitorSpecEndpointsOauth2TlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema ServiceMonitorSpecEndpointsOauth2TlsConfigCaSecret
 */
export interface ServiceMonitorSpecEndpointsOauth2TlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ServiceMonitorSpecEndpointsOauth2TlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ServiceMonitorSpecEndpointsOauth2TlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ServiceMonitorSpecEndpointsOauth2TlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsOauth2TlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsOauth2TlsConfigCaSecret(obj: ServiceMonitorSpecEndpointsOauth2TlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema ServiceMonitorSpecEndpointsOauth2TlsConfigCertConfigMap
 */
export interface ServiceMonitorSpecEndpointsOauth2TlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema ServiceMonitorSpecEndpointsOauth2TlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ServiceMonitorSpecEndpointsOauth2TlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ServiceMonitorSpecEndpointsOauth2TlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsOauth2TlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsOauth2TlsConfigCertConfigMap(obj: ServiceMonitorSpecEndpointsOauth2TlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema ServiceMonitorSpecEndpointsOauth2TlsConfigCertSecret
 */
export interface ServiceMonitorSpecEndpointsOauth2TlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ServiceMonitorSpecEndpointsOauth2TlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ServiceMonitorSpecEndpointsOauth2TlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ServiceMonitorSpecEndpointsOauth2TlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsOauth2TlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsOauth2TlsConfigCertSecret(obj: ServiceMonitorSpecEndpointsOauth2TlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

